import streamlit as st
import plotly.express as px
import numpy as np

class UIManager:
    def __init__(self, data_manager):
        self.dm = data_manager

    def show_advanced_description(self, advanced):
        if advanced:
            st.write("""
            Advanced Option allows the program to read data that doesn't conform to a traditional structure.
            Use in case of irregular rows or columns.
            """)

    def display_original_data(self):
        st.write("### Original Data Preview")
        st.dataframe(self.dm.original_data, use_container_width=True)

    def assign_columns_and_range(self):
        df = self.dm.original_data
        st.subheader("Assign Columns and Select Data Range")

        self.dm.date_col = st.selectbox("Select Date Column (Required)", df.columns, key="date")
        st.warning("""Note: If Deposits and Withdrawals are in a single column, select the same column for both parameters""")
        self.dm.dep_col = st.selectbox("Select Deposit Column (Required)", df.columns, key="deposit")
        self.dm.wit_col = st.selectbox("Select Withdrawal Column (Required)", df.columns, key="withdrawal")
        self.dm.description_col = st.selectbox("Select Description Column (Optional)", [None] + list(df.columns), key="description")
        self.dm.balance_col = st.selectbox("Select Balance Column (Optional)", [None] + list(df.columns), key="balance")

        st.write("### Select Data Range")
        self.dm.start_row = st.number_input("Start Row", min_value=0, max_value=len(df) - 1, value=0, step=1, key="start_row")
        self.dm.end_row = st.number_input("End Row", min_value=0, max_value=len(df), value=len(df), step=1, key="end_row")

        return st.button("Generate Derived Data")

    def get_active_df(self):
        df = st.session_state.get("filtered_data")
        if df is None or df.empty:
            df = st.session_state.get("derived_data")
        if df is None or df.empty:
            st.warning("No data to display.")
            return None
        return df.copy()

    def display_date_range_selector(self):
        df = st.session_state.get("derived_data")
        if df is None or df.empty:
            return

        min_date = df["Date"].min().date()
        max_date = df["Date"].max().date()

        st.subheader("Filter Data by Date Range")
        start_date = st.date_input("Start Date", min_value=min_date, max_value=max_date, value=min_date, key="start_date_input")
        end_date = st.date_input("End Date", min_value=min_date, max_value=max_date, value=max_date, key="end_date_input")

        if start_date > end_date:
            st.error("Start date cannot be after end date. Please adjust your selection.")
        else:
            filtered_df = df[(df["Date"].dt.date >= start_date) & (df["Date"].dt.date <= end_date)]
            st.session_state["filtered_data"] = filtered_df

    def display_derived_data(self):
        df = self.get_active_df()
        if df is not None:
            if self.dm.synthetic_data:
                st.warning("Current Data in use has been generated by program.")
            st.subheader("Derived Data (Transformed View)")
            st.dataframe(df, use_container_width=True)

    def display_account_activity_graph(self):
        df = self.get_active_df()
        if df is None:
            return

        if "Date" not in df.columns or "Amount" not in df.columns:
            st.error("The derived data is missing required columns: 'Date' and 'Amount'.")
            return

        st.subheader("Account Activity Over Time")
        time_period = st.radio("Select Timeframe", ("Total", "Yearly", "Monthly", "Daily"), key="timeframe_selection")

        if time_period == "Total":
            fig = px.line(df, x="Date", y="Amount", title="Complete Account Activity")
        elif time_period == "Yearly":
            df["Year"] = df["Date"].dt.year
            activity = df.groupby("Year")["Amount"].sum()
            fig = px.line(activity, x=activity.index, y="Amount", title="Yearly Account Activity")
        elif time_period == "Monthly":
            df["Month"] = df["Date"].dt.to_period("M")
            activity = df.groupby("Month")["Amount"].sum()
            fig = px.line(activity, x=activity.index.astype(str), y="Amount", title="Monthly Account Activity")
        else:
            df["Day"] = df["Date"].dt.date
            activity = df.groupby("Day")["Amount"].sum()
            fig = px.line(activity, x=activity.index, y="Amount", title="Daily Account Activity")

        st.plotly_chart(fig)

    def display_income_expense_summary(self):
        df = self.get_active_df()
        if df is None:
            return

        if "Description" not in df.columns or "Amount" not in df.columns:
            st.warning("Missing required columns for income/expense summary.")
            return

        st.subheader("Income and Expenses by Description")
        df["Type"] = np.where(df["Amount"] >= 0, "Income", "Expense")
        grouped = df.groupby(["Type", "Description"])["Amount"].sum().reset_index()

        for t in ["Income", "Expense"]:
            st.write(f"### {t}")
            filtered = grouped[grouped["Type"] == t]
            if filtered.empty:
                st.warning(f"No {t.lower()} data available.")
                continue

            fig = px.bar(filtered, x="Description", y="Amount", title=f"{t} by Description")
            st.plotly_chart(fig)
            st.write(f"Total {t}: {filtered['Amount'].sum():,.2f}")

            df_filtered = df[df["Type"] == t]
            yearly = df_filtered.groupby(df_filtered["Date"].dt.year)["Amount"].sum()
            monthly = df_filtered.groupby(df_filtered["Date"].dt.to_period("M"))["Amount"].sum()
            weekly = df_filtered.groupby(df_filtered["Date"].dt.to_period("W"))["Amount"].sum()

            st.write(f"#### Aggregates for {t}")
            st.write(f"- **Yearly Average {t}**: {yearly.mean():,.2f}")
            st.write(f"- **Monthly Average {t}**: {monthly.mean():,.2f}")
            st.write(f"- **Weekly Average {t}**: {weekly.mean():,.2f}")

    def display_balance_graph(self):
        df = self.get_active_df()
        if df is None or "Balance" not in df.columns or df["Balance"].dropna().empty:
            st.info("Balance column not selected or contains no valid data.")
            return

        st.subheader("Balance Over Time")
        balance_data = df.sort_values(by="Date")[["Date", "Balance"]].dropna()
        if balance_data.empty:
            st.warning("No valid data available for balance plotting.")
        else:
            fig = px.line(balance_data, x="Date", y="Balance", title="Balance Over Time")
            st.plotly_chart(fig)
